import { PATH_DATA_DIR, crashDuration } from './configuration';
import CVEPathData from './CVEPathData';
import Vehicle, { CrashType } from './Vehicle';
import each from 'jest-each';

// really imported from __mocks__/uuid
import * as realUuid from 'uuid';
import * as mockUuid from './__mocks__/uuid';

const { v4: mockGenUuid, fakeUuidValue } =
    realUuid as unknown as typeof mockUuid;

describe('Vehicle', () => {
    let cvePathData: CVEPathData;
    const fakePathId = 'fake_path_id';
    const fakePath = [
        { fakeCVEData: 'one', speed: 1 },
        { fakeCVEData: 'two', speed: 2 },
    ];

    beforeAll(async () => {
        jest.mock(
            `${PATH_DATA_DIR}/${fakePathId}_cleaned.json`,
            () => fakePath,
            {
                virtual: true,
            },
        );
        cvePathData = new CVEPathData([fakePathId]);
        await cvePathData.loadCVEData();
    });

    beforeEach(() => {
        jest.useFakeTimers();
        mockGenUuid.mockClear();
    });

    afterEach(() => {
        jest.clearAllTimers();
        jest.useRealTimers();
    });

    each([
        ['initial load sets first point', 0, 0],
        ['#advanceOnPath basic advance', 1, 1],
        ['#advanceOnPath cycles to beginning', 2, 0],
    ]).it('"%s"', (text, numberOfAdvances, expectedPoint) => {
        const v = new Vehicle(fakePathId, cvePathData);
        for (let i = 0; i < numberOfAdvances; i++) {
            v.advanceOnPath();
        }
        const result = v.getCurrentLocation();
        expect(result).toEqual({
            path_id: fakePathId,
            vehicle_id: fakeUuidValue,
            is_crashed: false,
            crash_type: null,
            ...fakePath[expectedPoint],
        });
    });

    it('#crash sets isCrashed to true', () => {
        const v = new Vehicle(fakePathId, cvePathData);

        expect(v.isCrashed()).toBe(false);
        v.crash(CrashType.ManuallyTriggered);
        expect(v.isCrashed()).toBe(true);
    });

    it("#crash returns the vehicle's id", () => {
        const v = new Vehicle(fakePathId, cvePathData);

        expect(v.isCrashed()).toBe(false);
        const id = v.crash(CrashType.ManuallyTriggered);
        expect(id).toBe(fakeUuidValue);
    });

    it('#crash performs a reset after the configured duration', () => {
        const v = new Vehicle(fakePathId, cvePathData);
        const spyReset = jest.spyOn(v, 'reset');

        expect(jest.getTimerCount()).toBe(0);

        v.crash(CrashType.ManuallyTriggered);
        expect(jest.getTimerCount()).toBe(1);

        expect(spyReset).not.toHaveBeenCalled();
        jest.advanceTimersByTime(crashDuration);
        expect(spyReset).toHaveBeenCalled();
    });

    it('#getCurrentLocation has speed as 0 when isCrashed', () => {
        const v = new Vehicle(fakePathId, cvePathData);

        v.crash(CrashType.ManuallyTriggered);
        expect(v.getCurrentLocation()).toMatchObject({
            speed: 0,
        });
    });

    it('#getCurrentLocation reflects the provided crash_type after a crash', () => {
        const v = new Vehicle(fakePathId, cvePathData);

        v.crash(CrashType.ManuallyTriggered);
        expect(v.getCurrentLocation()).toMatchObject({
            crash_type: 'MANUAL',
        });
        v.crash(CrashType.AutomaticallyTriggered);
        expect(v.getCurrentLocation()).toMatchObject({
            crash_type: 'AUTOMATIC',
        });
    });

    it('#getCurrentLocation contains is_crashed when isCrashed', () => {
        const v = new Vehicle(fakePathId, cvePathData);

        expect(v.getCurrentLocation()).toMatchObject({
            is_crashed: false,
        });
        v.crash(CrashType.ManuallyTriggered);
        expect(v.getCurrentLocation()).toMatchObject({
            is_crashed: true,
        });
    });

    it('#reset should restore is_crashed to false', () => {
        const v = new Vehicle(fakePathId, cvePathData);
        v.crash(CrashType.ManuallyTriggered);

        v.reset();
        expect(v.getCurrentLocation()).toMatchObject({
            is_crashed: false,
        });
    });

    it('#reset should restore crash_type to null', () => {
        const v = new Vehicle(fakePathId, cvePathData);
        v.crash(CrashType.ManuallyTriggered);

        v.reset();
        expect(v.getCurrentLocation()).toMatchObject({
            crash_type: null,
        });
    });

    it('#reset should restore vehicle point to initial point', () => {
        const v = new Vehicle(fakePathId, cvePathData);
        v.advanceOnPath();

        v.reset();
        expect(v.getCurrentLocation()).toMatchObject(fakePath[0]);
    });

    it('#reset should assign a new vehicle id', () => {
        const v = new Vehicle(fakePathId, cvePathData);
        const alternateUuid = '11111111-1111-1111-1111-111111111111';

        expect(v.getCurrentLocation()).toMatchObject({
            vehicle_id: fakeUuidValue,
        });

        mockGenUuid.mockImplementationOnce(() => alternateUuid);
        v.reset();

        expect(mockGenUuid).toHaveBeenCalledTimes(2);
        expect(v.getCurrentLocation()).toMatchObject({
            vehicle_id: alternateUuid,
        });
    });
});
