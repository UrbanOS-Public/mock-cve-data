import { PATH_DATA_DIR } from './configuration';
import CVEPathData from './CVEPathData';
import Vehicle from './Vehicle';

jest.mock('uuid', () => ({ v4: () => '00000000-0000-0000-0000-000000000000' }));

describe('Vehicle', () => {
    let cvePathData: CVEPathData;
    const fakePathId = 'fake_path_id';
    const fakePath = [{ fakeCVEData: 'one' }, { fakeCVEData: 'two' }];

    beforeAll(async () => {
        jest.resetModules();
        jest.restoreAllMocks();
        jest.mock(`${PATH_DATA_DIR}/${fakePathId}.json`, () => fakePath, {
            virtual: true,
        });
        cvePathData = new CVEPathData([fakePathId]);
        await cvePathData.loadCVEData();
    });

    it('#getCurrentLocation returns the first point of a path after initialization', () => {
        const v = new Vehicle(fakePathId, cvePathData);
        expect(v.getCurrentLocation()).toEqual({
            pathId: fakePathId,
            vehicleId: '00000000-0000-0000-0000-000000000000',
            ...fakePath[0],
        });
    });

    it('#advanceOnPath updates the vehicle location', () => {
        const v = new Vehicle(fakePathId, cvePathData);
        v.advanceOnPath();
        const result = v.getCurrentLocation();
        expect(result).toEqual({
            pathId: fakePathId,
            vehicleId: '00000000-0000-0000-0000-000000000000',
            ...fakePath[1],
        });
    });

    it('#advanceOnPath cycles back to beginning after reaching last point', () => {
        const v = new Vehicle(fakePathId, cvePathData);
        const numberOfPointsOnPath = fakePath.length;
        for (let i = 0; i < numberOfPointsOnPath; i++) {
            v.advanceOnPath();
        }
        const result = v.getCurrentLocation();
        expect(result).toEqual({
            pathId: fakePathId,
            vehicleId: '00000000-0000-0000-0000-000000000000',
            ...fakePath[0],
        });
    });
});
