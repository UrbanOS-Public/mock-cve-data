import app from '../app';
import supertest from 'supertest';
import { PATH_IDS } from '../configuration';
import { PathPoint } from '../CVEPathData';

// see mocking_readme.md for detailed overview of how mocking works
import * as MockCVEPathData from '../__mocks__/CVEPathData';
import * as CVEPathData from '../CVEPathData';

const { default: mockCVEPathDataConstructor, fakePath } =
    CVEPathData as unknown as typeof MockCVEPathData;

jest.mock('../CVEPathData');
jest.mock('../VehicleMover');

describe('GET - /data', () => {
    it('Returns the first point of each path', async () => {
        const res = await supertest(app).get('/data');
        const paths = res.body as PathPoint[];

        expect(paths?.length).toBeTruthy();
        paths.forEach((pathPoint, i) => {
            expect(pathPoint).toMatchObject({
                ...fakePath[0],
                path_id: PATH_IDS[i],
                vehicle_id: '00000000-0000-0000-0000-000000000000',
            });
        });
    });

    it("Doesn't re-load CVE data on subsequent requests", async () => {
        await supertest(app).get('/data');
        await supertest(app).get('/data');
        expect(mockCVEPathDataConstructor).toHaveBeenCalledTimes(1);
    });

    it('The response aligns with the Event Data Hub Model', async () => {
        const res = await supertest(app).get('/data');
        const point = res.body[0];
        const dataHubModel = {
            vehicle_id: expect.any(String),
            lat: expect.any(Number),
            long: expect.any(Number),
            speed: expect.any(Number),
            speed_unit: expect.any(String),
            is_crashed: expect.any(Boolean),
        };
        expect(point).toEqual(expect.objectContaining(dataHubModel));
    });
});
