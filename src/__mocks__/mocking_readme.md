Quick overview of how jest class mocks work with typescript, since there wasn't
much detailed info online.

The short is: Reference `__mocks__/VehicleMover` as an example, along with it's
usage in `app.test.ts`.

Below are detailed instructions.

Ideally, this process is made more readable / intuitive, and this readme can be
deleted once that's so.

### Creating a mock class

-   A class is defined in `__mocks__` with the following requirements
    -   the name of the file matches the name of the file it's mocking
    -   Reference `VehicleMover.ts` as a mock definition example:
        -   the default export of the file is the mocked class
        -   the mocked class is an object returned to `jest.fn().mockImplementation`
        -   Any mocked functions are defined / exported outside of the mock class definition

### Utilizing a mock class in a test

-   `jest.mock('{path_to_custom_class}')` will replace ClassName with the defined mock in the runtime.
-   This must be executed at the beginning of a file, above any `describe` blocks
-   If you'd like to assert what was called / interact with the mock in the test, You'll need to import both the mock and the real class, using the `* as ---` syntax in your test code. See the VehicleMover imports in App.test.ts as an example.

You'll be able to pull things from the mock class _through_ the "real" class,
while assuring typescript that what you're doing is okay:

```typescript
// Give me the mock class i've defined in __mocks__/{classname} and let me
//    name it mock{ClassName}Constructor
// Give me the mock function i've defined in __mocks__/{classname}
const { default: mockVehicleMoverConstructor, mockStartMovingVehicles } =
    // Get these things from the VehicleMover class, because I know that jest
    //     has secretly replaced it with the contents of MockVehicleMover
    VehicleMover as unknown as typeof MockVehicleMover;
// Tell typescript that these things are really coming from MockVehicleMover
```

### Potential Improvements

Anything to make mocking more read-able. It stinks that we need a readme to
describe it due to the nature of casting imports.

-   [ ] A way to combine "real" and "mock" imports into a single import?

I don't think this is possible or I'd have done it but, if someone can find a
way to condense the following into one import, that'd be neat.

```typescript
import * as MockCVEPathData from './__mocks__/CVEPathData';
import * as CVEPathData from './CVEPathData'; // __mocks__/CVEPathData
```

Additionally, the type casting required to access mock class properties might
be able to be encapsulated inside that import condense strategy:

```typescript
jest.mock('./CVEPathData');
// aka: moving this to properties of the unified import
//      this way type casting doesn't have to be performed in test code
const {
    default: mockCVEPathDataConstructor,
    mockLoadCVEData,
    fakePath,
} = CVEPathData as unknown as typeof MockCVEPathData;
```
