Quick overview of how jest class mocks work with typescript, since there wasn't
much detailed info online.

The short is: Reference `__mocks__/VehicleMover` as an example, along with it's
usage in `app.test.ts`. Anytime you want to import something from a file in
`__mocks__`, you have to instead import it from the non-mock equivalent, and tell
typescript it's okay to do so.

Below are detailed instructions.

Ideally, this process is made more readable / intuitive, and this readme can be
deleted once that's so.

### Creating a mock class

-   A class is defined in `__mocks__` with the following requirements
    -   the name of the file matches the name of the file it's mocking
    -   Reference `VehicleMover.ts` as a mock definition example:
        -   the default export of the file is the mocked class
        -   the mocked class is an object returned to `jest.fn().mockImplementation`
        -   Any mocked functions are defined / exported outside of the mock class definition

### Utilizing a mock class in a test

-   `jest.mock('{path_to_custom_class}')` will replace ClassName with the defined mock in the runtime.
-   This must be executed at the beginning of a file, above any `describe` blocks
-   If you'd like to assert what was called / interact with the mock in the test, You'll need to import both the mock and the real class, using the `* as ---` syntax in your test code. See the VehicleMover imports in App.test.ts as an example.

You'll be able to pull things from the mock class _through_ the "real" class,
while assuring typescript that what you're doing is okay:

```typescript
// Give me the mock class i've defined in __mocks__/{classname} and let me
//    name it mock{ClassName}Constructor
// Give me the mock function i've defined in __mocks__/{classname}
const { default: mockVehicleMoverConstructor, mockStartMovingVehicles } =
    // Get these things from the VehicleMover class, because I know that jest
    //     has secretly replaced it with the contents of MockVehicleMover
    VehicleMover as unknown as typeof MockVehicleMover;
// Tell typescript that these things are really coming from MockVehicleMover
```

If you want to override an existing mock for example, refer to crash.test.ts

You'll need to import the function from the mock, _through_ the "real" class,
and then can override mockImplementation

### Mock Factories

Mock Factories are functions that return a customizable class mock.
These are useful when mocks will be altered depending on the context of a
test. Ex: I need a crashed vehicle followed by a non-crashed vehicle.

See `__mocks__/vehicle.ts` for an example

### Potential Improvements

Anything to make mocking more read-able. It stinks that we need a readme to
describe it due to the nature of casting imports.

-   [ ] A way to combine "real" and "mock" imports into a single import?

I don't think this is possible or I'd have done it but, if someone can find a
way to condense the following into one import, that'd be neat.

```typescript
import * as MockCVEPathData from './__mocks__/CVEPathData';
import * as CVEPathData from './CVEPathData'; // __mocks__/CVEPathData
```

Additionally, the type casting required to access mock class properties might
be able to be encapsulated inside that import condense strategy:

```typescript
jest.mock('./CVEPathData');
// aka: moving this to properties of the unified import
//      this way type casting doesn't have to be performed in test code
const {
    default: mockCVEPathDataConstructor,
    mockLoadCVEData,
    fakePath,
} = CVEPathData as unknown as typeof MockCVEPathData;
```
