import * as fs from 'fs';
import { v4 as uuidv4 } from 'uuid';
import moment from 'moment';

import CVEPathData, { PathPoint } from '../../CVEPathData';
import { PATH_IDS } from '../../configuration';
import {
    crashesPerPath,
    exportedFileName,
    logDontExport,
    timeRange,
} from './configuration';

interface CrashedPathPoint extends PathPoint {
    vehicle_id: string;
    is_crashed: boolean;
    path_id: string;
}

let crashCounter = 0;
let dataToExport = [] as CrashedPathPoint[];

const pathData = new CVEPathData(PATH_IDS);

/////////////////////////////////////////////////////////////
// Load existing cve data, make crashes out of it, export it
pathData.loadCVEData().then(() => {
    PATH_IDS.forEach((path_id) => {
        while (crashCounter < crashesPerPath) {
            const point = getRandomPointOnPath(path_id);
            const crashedPoint = crashAPoint(point, path_id);
            dataToExport.push(crashedPoint);
            crashCounter++;
        }
        resetCrashCounter();
    });
    sortExportByTime();
    exportData();
});

/////////////////////////////////////////////////////////////
// Helper functions
const resetCrashCounter = () => {
    crashCounter = 0;
};

const getRandomPointOnPath = (path_id: string): PathPoint => {
    const path = pathData.getPath(path_id);
    const randomPointIndex = getRandomIntInRange(path.length);
    return path[randomPointIndex];
};

const getRandomIntInRange = (max: number) => Math.floor(Math.random() * max);

const crashAPoint = (point: PathPoint, path_id: string): CrashedPathPoint => {
    return {
        ...point,
        is_crashed: true,
        vehicle_id: uuidv4(),
        timestamp: getRandomTimeInRange(),
        path_id: path_id,
    };
};

const getRandomTimeInRange = () => {
    const end = new Date();
    const start = moment()
        .subtract(timeRange.days, 'days')
        .subtract(timeRange.months, 'months')
        .toDate();

    return new Date(
        start.getTime() + Math.random() * (end.getTime() - start.getTime()),
    ).toISOString();
};

const exportData = () => {
    if (logDontExport) {
        console.log(dataToExport);
    } else {
        fs.writeFileSync(
            __dirname + `/${exportedFileName}.json`,
            JSON.stringify(dataToExport, null, 2),
            { flag: 'w', encoding: 'utf-8' },
        );
    }
};

const sortExportByTime = () => {
    dataToExport = dataToExport.sort(
        (a, b) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime(),
    );
};
