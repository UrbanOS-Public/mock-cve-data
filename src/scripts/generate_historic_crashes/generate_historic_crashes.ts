import * as fs from 'fs';
import { v4 as uuidv4 } from 'uuid';
import moment from 'moment';

import CVEPathData, { PathPoint } from '../../CVEPathData';
import { PATH_IDS } from '../../configuration';
import {
    crashesPerPath,
    exportedFileName,
    logDontExport,
    timeRange,
    percentOfCrashesOver64KPH,
} from './configuration';

interface CrashedPathPoint extends PathPoint {
    vehicle_id: string;
    is_crashed: boolean;
    path_id: string;
}

let crashCounter = 0;
let dataToExport = [] as CrashedPathPoint[];

const pathData = new CVEPathData(PATH_IDS);

/////////////////////////////////////////////////////////////
// Load existing cve data, make crashes out of it, export it
pathData.loadCVEData().then(() => {
    PATH_IDS.forEach((path_id) => {
        while (crashCounter < crashesPerPath) {
            const point = getRandomPointOnPath(path_id);
            const crashedPoint = crashAPoint(point, path_id);
            dataToExport.push(crashedPoint);
            crashCounter++;
        }
        resetCrashCounter();
    });
    adjustSpeed();
    sortExportByTime();
    exportData();
    logDetailsOfExport();
});

/////////////////////////////////////////////////////////////
// Helper functions
const resetCrashCounter = () => {
    crashCounter = 0;
};

const getRandomPointOnPath = (path_id: string): PathPoint => {
    const path = pathData.getPath(path_id);
    const randomPointIndex = getRandomIntInRange(path.length);
    return path[randomPointIndex];
};

const getRandomIntInRange = (max: number) => Math.floor(Math.random() * max);

const crashAPoint = (point: PathPoint, path_id: string): CrashedPathPoint => {
    return {
        ...point,
        is_crashed: true,
        vehicle_id: uuidv4(),
        timestamp: getRandomTimeInRange(),
        path_id: path_id,
    };
};

const getRandomTimeInRange = () => {
    const end = new Date();
    const start = moment()
        .subtract(timeRange.days, 'days')
        .subtract(timeRange.months, 'months')
        .toDate();

    return new Date(
        start.getTime() + Math.random() * (end.getTime() - start.getTime()),
    ).toISOString();
};

const exportData = () => {
    if (logDontExport) {
        console.log(dataToExport);
    } else {
        fs.writeFileSync(
            __dirname + `/${exportedFileName}.json`,
            JSON.stringify(dataToExport, null, 2),
            { flag: 'w', encoding: 'utf-8' },
        );
    }
};

const sortExportByTime = () => {
    dataToExport = dataToExport.sort(
        (a, b) =>
            new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime(),
    );
};

const adjustSpeed = (): void => {
    let pointsOver64KPH = 0;
    const desiredPointsOver64KPH =
        percentOfCrashesOver64KPH * dataToExport.length;

    dataToExport.forEach((crash) => {
        const shouldCrashOver64 = pointsOver64KPH <= desiredPointsOver64KPH;
        crash.speed = shouldCrashOver64
            ? getRandomSpeed({ lowerLimit: 64 })
            : getRandomSpeed({ upperLimit: 64 });
        pointsOver64KPH++;
    });
};

const logDetailsOfExport = () => {
    let i = 0;
    dataToExport.forEach((crash) => {
        if (crash.speed >= 64) i++;
    });
    const percentAbove64 = i / dataToExport.length;
    console.log(`////////////////////////////////////////////`);
    console.log(`Exported file`);
    console.log(`${round(percentAbove64, 2)}% of crashes above 64kph`);
    console.log(`////////////////////////////////////////////`);
};

const getRandomSpeed = ({ lowerLimit = 0, upperLimit = 100 }) => {
    return (upperLimit - lowerLimit) * Math.random() + lowerLimit;
};

const round = (num: number, places: number) => {
    const multi = Math.pow(10, places);
    return Math.round(num * multi) / multi;
};
