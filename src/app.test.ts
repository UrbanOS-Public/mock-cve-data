import app from './app';
import supertest from 'supertest';
import { HEALTH_MSG, PATH_IDS } from './configuration';
import { PathPoint } from './CVEPathData';

// see mocking_readme.md for detailed overview of how mocking works
import * as MockVehicleMover from './__mocks__/VehicleMover';
import * as VehicleMover from './VehicleMover';

import * as MockCVEPathData from './__mocks__/CVEPathData';
import * as CVEPathData from './CVEPathData';

jest.mock('uuid', () => ({ v4: () => '00000000-0000-0000-0000-000000000000' }));

jest.mock('./CVEPathData');
const {
    default: mockCVEPathDataConstructor,
    mockLoadCVEData,
    fakePath,
} = CVEPathData as unknown as typeof MockCVEPathData;

jest.mock('./VehicleMover');
const { default: mockVehicleMoverConstructor, mockStartMovingVehicles } =
    VehicleMover as unknown as typeof MockVehicleMover;

describe('Application', () => {
    it('Loads CVE data on app start', async () => {
        await supertest(app);
        expect(mockLoadCVEData).toHaveBeenCalledTimes(1);
    });

    it('Constructs A CVEPathData instance with the configured PathIDs on app start', async () => {
        await supertest(app);
        expect(mockCVEPathDataConstructor).toHaveBeenCalledWith(PATH_IDS);
    });

    it('Puts vehicles in motion with VehicleMover on app start', async () => {
        await supertest(app);
        expect(mockVehicleMoverConstructor).toHaveBeenCalledTimes(1);
        expect(mockStartMovingVehicles).toHaveBeenCalledTimes(1);
    });

    describe('GET - /healthcheck', () => {
        it('returns healthy', async () => {
            const res = await supertest(app).get('/healthcheck');
            expect(res.text).toEqual(HEALTH_MSG);
            expect(res.statusCode).toEqual(200);
        });
    });

    describe('GET - /data', () => {
        it('Returns the first point of each path', async () => {
            const res = await supertest(app).get('/data');
            const paths = res.body as PathPoint[];

            expect(paths?.length).toBeTruthy();
            paths.forEach((pathPoint, i) => {
                expect(pathPoint).toEqual({
                    ...fakePath[0],
                    pathId: PATH_IDS[i],
                    vehicleId: '00000000-0000-0000-0000-000000000000',
                });
            });
        });

        it("Doesn't re-load CVE data on subsequent requests", async () => {
            await supertest(app).get('/data');
            await supertest(app).get('/data');
            expect(mockCVEPathDataConstructor).toHaveBeenCalledTimes(1);
        });
    });

    // describe('GET - /crash', () => {});
    // crash endpoint calls vehiclecrashservice.crash
    // VCS.crash calls V.crash on the first V that doesn't have V.isCrashed
    // VCS.crash if all crashed returns 400 with desc
    // V.crash sets V.isCrashed to true
    // V.getCurrentLocation sets speed to 0 if isCrashed
    // V.getCurrentLocation has is_crashed
    // VH.advanceAllVehicles considers V.isCrashed
});
